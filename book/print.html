<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pebble OS</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="expanded "><a href="kernel/index.html"><strong aria-hidden="true">2.</strong> The Kernel</a></li><li><ol class="section"><li class="expanded "><a href="kernel/bootcmd.html"><strong aria-hidden="true">2.1.</strong> Bootcmd</a></li><li class="expanded "><a href="kernel/booting_x86_64.html"><strong aria-hidden="true">2.2.</strong> Booting (x86_64)</a></li><li class="expanded "><a href="kernel/object_ids.html"><strong aria-hidden="true">2.3.</strong> Kernel Object IDs</a></li><li class="expanded "><a href="kernel/syscalls.html"><strong aria-hidden="true">2.4.</strong> System calls</a></li></ol></li><li class="expanded "><a href="syscalls/index.html"><strong aria-hidden="true">3.</strong> Syscalls</a></li><li><ol class="section"><li class="expanded "><a href="syscalls/yield.html"><strong aria-hidden="true">3.1.</strong> yield</a></li><li class="expanded "><a href="syscalls/early_log.html"><strong aria-hidden="true">3.2.</strong> early_log</a></li><li class="expanded "><a href="syscalls/request_system_object.html"><strong aria-hidden="true">3.3.</strong> request_system_object</a></li><li class="expanded "><a href="syscalls/my_address_space.html"><strong aria-hidden="true">3.4.</strong> my_address_space</a></li><li class="expanded "><a href="syscalls/map_memory_object.html"><strong aria-hidden="true">3.5.</strong> map_memory_object</a></li></ol></li><li class="expanded "><a href="userspace/index.html"><strong aria-hidden="true">4.</strong> Userspace</a></li><li><ol class="section"><li class="expanded "><a href="userspace/capabilities.html"><strong aria-hidden="true">4.1.</strong> Capabilities</a></li><li class="expanded "><a href="userspace/memory_map_x86_64.html"><strong aria-hidden="true">4.2.</strong> Memory map (x86_64)</a></li></ol></li><li class="expanded "><a href="message_passing/index.html"><strong aria-hidden="true">5.</strong> Message Passing</a></li><li><ol class="section"><li class="expanded "><a href="message_passing/fmt.html"><strong aria-hidden="true">5.1.</strong> Message Format</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Pebble OS</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to the Pebble Book, which serves as the main source of documentation for <a href="https://github.com/IsaacWoods/pebble">Pebble OS</a>.
The Book aims to be both a 10,000-meter overview of Pebble for the interested observer, and a definitive reference for the inner workings of the kernel and userspace. </p>
<p>Please note that this book (like the rest of the OS!) is still very early in development and not at all complete.
If anything is unclear, please <a href="https://github.com/IsaacWoods/pebble/issues">file an issue</a>!</p>
<p><strong>Some things documented in this book don't exist in Pebble yet. I use the book as in-progress documentation as I design stuff so I don't have to keep it all in my head.</strong></p>
<h3><a class="header" href="#what-is-pebble" id="what-is-pebble">What is Pebble?</a></h3>
<p>At heart, Pebble is a microkernel written in the <a href="https://rust-lang.org">Rust programming language</a>.
Pebble becomes an &quot;OS&quot; when it's combined with other packages such as display and window servers, filesystems and user applications.</p>
<p>Pebble is designed to be a modern microkernel, supporting a minimal system call interface and first-class support for message-passing-based IPC between userspace processes. Versatile message-passing allows
Pebble to move much more out of the kernel than traditionally possible. For example, the kernel has no concept of a filesystem or of files - instead, the VFS and all filesystems are implemented entirely in
userspace, and files are read and written to by passing messages.</p>
<h3><a class="header" href="#why-rust" id="why-rust">Why Rust?</a></h3>
<p>While Pebble's design is in theory language-agnostic, the implementation is very tied to Rust. Rust is a systems programming language with a rich type system and a novel ownership model that guarantees
memory and thread safety <strong>in safe code</strong>. This qualification is important, as Pebble uses a lot of <code>unsafe</code> code out of necessity - it's important to understand that the use of Rust does not in any way
mean that Pebble is automatically bug-free.</p>
<p>However, Rust makes you think a lot more about how to make your programs safe, which is exactly the sort of code we want to be writing for a kernel. This focus on safety, as well as good ergonomics features
and performance, makes Rust perfect for OS-level code.</p>
<h3><a class="header" href="#arch-modules" id="arch-modules">Arch modules</a></h3>
<p>Each architecture has its own module that deals with platform-specific initialization and platform management.
When building, a single architecture module is selected using an architecture feature. Through conditional
compilation, only the selected architecture module is compiled and included in the final kernel executable.</p>
<p>Every architecture module is expected to provide certain items for the benefit of the platform-independent
parts of the kernel:</p>
<ul>
<li><code>Arch</code> - A type that implements the <code>Architecture</code> trait.</li>
<li><code>common_per_cpu_data</code> - A function to access the common per-cpu data.</li>
<li><code>common_per_cpu_data_mut</code> - A function to mutably access the common per-cpu data.</li>
<li><code>context_switch</code> - A function to perform a context switch between the currently running task and another task.</li>
</ul>
<h1><a class="header" href="#bootcmd" id="bootcmd">Bootcmd</a></h1>
<p>The <code>bootcmd</code> is a file loaded by the bootloader that contains instructions for booting into an instance of Pebble.
It is located at the root of the boot medium (e.g. in the FAT partition if using the UEFI bootloader for x86_64),
and consists of a series of line-separated commands that load / configure parts of the OS.</p>
<h3><a class="header" href="#commands" id="commands">Commands</a></h3>
<ul>
<li><code>kernel {path}</code> - load the kernel image at the specified path into memory. This command must be present for the
bootloader to successfully boot, and must only appear once in the <code>bootcmd</code>.</li>
<li><code>image {path} {name}</code> - load an initial task image into memory and pass information about it to the kernel. This
command is used to load initial tasks for the kernel to run before it has functioning filesystem drivers. It
can also be used to load all tasks needed in minimal systems. It can be present zero or more times in the
<code>bootcmd</code>. The same image should not be loaded more than once, however.</li>
<li><code>video_mode {desired width} {desired height}</code> - attempts to set up a video mode for initial graphics support (if
a better driver isn't available / loaded). The exact behaviour of this command will depend on the platform
being booted upon, but it will in general try to switch to an appropriate mode, pass information about that
mode to the kernel, which will pass it on to the task with the <code>CAP_MAP_FRAMEBUFFER</code> capability (refer to
the 'Userspace/Capabilities' section for more information)</li>
</ul>
<h1><a class="header" href="#booting-pebble-on-x86_64" id="booting-pebble-on-x86_64">Booting Pebble on x86_64</a></h1>
<p>On x86_64, Pebble is booted by a UEFI application that can be found <a href="https://github.com/pebble-os/pebble/tree/master/bootloader">here</a>. We don't support booting from BIOS, mainly because the vast majority
of current platforms now support UEFI, and I didn't want the maintenance burden of two bootloaders for one platform. Pebble's kernel and bootloaders are more coupled than on other platforms, and the
bootloader does a lot more of the platform-specific initialization than generic bootloaders like GRUB2. On x86_64, doing this initialization in the bootloader allows us to use the Boot Services provided by
the UEFI, which simplifies early bring-up considerably.</p>
<p>The bootloader is responsible for setting up a sensible environment for the kernel to run in, as well as doing initialization that makes use of the Boot Services that are not available after we've loaded the
kernel. This is much easier than it would be if we supported the BIOS, as UEFI already defines a fairly sane environment. The bootloader:</p>
<ul>
<li>Finds and switches to a suitable graphics mode</li>
<li>Loads the kernel's image from the boot partition, loads its sections, and creates a set of page tables for it</li>
<li>Loads the payload's image from the boot partition, loads its sections, and creates a set of page tables for it</li>
<li>Allocates backing memory for the kernel heap</li>
<li>Sets up paging and creates page tables with the correct kernel-space mappings</li>
<li>Jumps into the kernel</li>
</ul>
<h3><a class="header" href="#loading-the-kernel" id="loading-the-kernel">Loading the kernel</a></h3>
<p>The kernel is an ELF file on the boot partition. Only its allocatable sections are mapped into memory. The kernel is expected to have a couple of special symbols defined, which are used by the bootloader:</p>
<ul>
<li><code>_guard_page</code> - the start address of the guard page. This is purposefully unmapped by the bootloader, so that stack overflows cause page-faults</li>
<li><code>_stack_bottom</code> and <code>_stack_top</code> - define the bottom and top of the stack, respectively. These are defined as part of the <code>.bss</code> section, so the bootloader doesn't have to manually allocate a stack. The 
address is provided so the bootloader knows what to set <code>rsp</code> to before it jumps into the kernel</li>
</ul>
<h3><a class="header" href="#loading-the-kernel-payload" id="loading-the-kernel-payload">Loading the kernel payload</a></h3>
<p>While we have the luxury of the UEFI's filesystem drivers being available, we also load another ELF image called the 'kernel payload'. This is the first process launched by the kernel, and is usually
responsible for starting a set of other processes from an embedded initial filesystem. Alternatively, a simple application can be provided as a payload, for example in embedded contexts.</p>
<p>While it seems like a strange choice, we load this in the bootloader so that the kernel doesn't have to have any logic to do so. Pebble The Microkernel has no concept of files, of ramdisks, or of what an ELF
file looks like inside - it simply accepts sets of page tables and created processes out of them. This makes the kernel much simpler and less bug-prone, at the expense of making the bootloader slightly more
complex.</p>
<h1><a class="header" href="#kernel-object-ids" id="kernel-object-ids">Kernel Object IDs</a></h1>
<p>Pebble uses a slighly unusual system for allocating IDs for kernel objects. Inspired by an idea from
<a href="https://www.youtube.com/watch?v=aKLntZcp27M">Catherine West's Rustconf 2018 keynote</a>, we use <strong>generational
IDs</strong>. This means that kernel object IDs are comprised of two different numbers:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
fn main() {
</span>pub struct KernelObjectId {
    index: u16,
    generation: u16,
}
<span class="boring">}
</code></pre></pre>
<p>Note that the meaning of these numbers is only related to how the kernel manages the allocation of IDs, and
can be treated as a single ID by other parts of the system, and by tasks.</p>
<p>The key motivation behind this is called <a href="https://en.wikipedia.org/wiki/ABA_problem">the ABA problem</a>. Because
Pebble makes heavy use of message passing, tasks are expected to cache the IDs of various kernel objects that
they want to interact with often. However, because tasks can be created and destroyed at any point,
conventional IDs could lead to tasks messaging unrelated tasks that have been allocated the ID of a
previously-cached task. As shown by this example, this could even potentially lead to a malicious task
being able to intercept messages meant for something else:</p>
<ul>
<li>A logging task is created and allocated ID <code>17</code></li>
<li>Task A is created and wants to log stuff, so it looks up and caches the logger's ID</li>
<li>The logger is destroyed, leaving ID <code>17</code> free to allocate again</li>
<li>A malicious task is created, and is allocated ID <code>17</code></li>
<li>Task A sends a message to ID <code>17</code> - which is now not the logger, but this malicious task</li>
<li>The malicious task receives this message and exfiltrates it!</li>
</ul>
<p>Of course, this example is slightly convoluted because tasks should not be logging sensitive information in
the first place, but hopefully it's easy to see how this allocation scheme could lead to problems.</p>
<p>Generational IDs solve this problem by introducing a second component to the ID - the generation counter. When
a task is created, it is inserted into the generational data structure and allocated a free index - this
forms the first part of the ID. The generation of the ID is the current generation of that index in the data
structure. When the task is destroyed, it is removed from the data structure and its index's generation is
incremented. If you try to get the element at a given index, but the generations don't match, the data
structure acts if there's nothing at that index, because the thing you think is there no longer will be!</p>
<p>With this new ID system, let's see what happens in the same situation with the logger:</p>
<ul>
<li>A logger task is created and allocated ID <code>(17, 0)</code></li>
<li>Task A is created and wants to log stuff, so it looks up and caches the logger's ID</li>
<li>The logger is destroyed, and the generation of ID <code>17</code> is increased from <code>0</code> to <code>1</code></li>
<li>A malicious task is created, and is allocated ID <code>(17, 1)</code></li>
<li>Task A sends a message to ID <code>(17, 0)</code> - which is now not the logger and no longer exists</li>
<li>Task A receives a message saying the task at <code>(17, 0)</code> no longer exists</li>
<li>The malicious task fails to intercept Process A's logging</li>
</ul>
<p>And with that, our very convoluted malicious task has been defeated!</p>
<h1><a class="header" href="#system-calls" id="system-calls">System calls</a></h1>
<p>Userspace code can interact with the kernel through system calls. Unlike traditional monolithic kernels, Pebble's system call interface is designed to be very minimal; many of the operations traditionally
supported by system calls (such as filesystem operations) are not provided by the kernel in Pebble, and so are instead accessed through passing messages to other userspace processes.</p>
<p>Pebble's original design had userspace processes communicate with the kernel by passing messages to it, like it would communicate with another userspace process. Having a system call interface has a few
advantages over this design:</p>
<ul>
<li>System calls have much less overhead</li>
<li>Programs that otherwise wouldn't need to pass messages don't need the extra machinery to talk to the kernel</li>
<li>The kernel no longer has to deserialize messages. While it still contains some message-passing infrastructure, it only needs to pass the headers and <code>memcpy</code> stuff to the right place. This hugely reduces the
attack surface of the kernel.</li>
</ul>
<p>Each system call has a unique number that is used to identify it. A system call can then take up to five parameters, each a maximum in size of the system's register width. It can return a single value, also
the size of a register.</p>
<h3><a class="header" href="#overview-of-system-calls" id="overview-of-system-calls">Overview of system calls</a></h3>
<table><thead><tr><th>Number</th><th>System call</th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>Return value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>0</code></td><td><code>yield</code></td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>Yield to the kernel.</td></tr>
<tr><td><code>1</code></td><td><code>early_log</code></td><td>length of string</td><td>ptr to string</td><td>-</td><td>-</td><td>-</td><td>success / error</td><td>Log a message. Designed to be used from early processes.</td></tr>
<tr><td><code>2</code></td><td><code>request_system_object</code></td><td>object id</td><td>{depends on id}</td><td>{depends on id}</td><td>{depends on id}</td><td>{depends on id}</td><td>id of object + status</td><td>Request the id of a system kernel object.</td></tr>
<tr><td><code>3</code></td><td><code>my_address_space</code></td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>AddressSpace id</td><td>Get the id of the calling task's AddressSpace.</td></tr>
<tr><td><code>4</code></td><td><code>map_memory_object</code></td><td>MemoryObject id</td><td>AddressSpace id</td><td>-</td><td>-</td><td>-</td><td>success / error</td><td>Map a MemoryObject into an AddressSpace.</td></tr>
</tbody></table>
<h3><a class="header" href="#making-a-system-call-on-x86_64" id="making-a-system-call-on-x86_64">Making a system call on x86_64</a></h3>
<p>To make a system call on x86_64, populate these registers:</p>
<table><thead><tr><th><code>rdi</code></th><th><code>rsi</code></th><th><code>rdx</code></th><th><code>r10</code></th><th><code>r8</code></th><th><code>r9</code></th></tr></thead><tbody>
<tr><td>System call number</td><td><code>a</code></td><td><code>b</code></td><td><code>c</code></td><td><code>d</code></td><td><code>e</code></td></tr>
</tbody></table>
<p>The only way in which these registers deviate from the x86_64 Sys-V ABI is that <code>c</code> is passed in <code>r10</code> instead
of <code>rcx</code>. This is because <code>rcx</code> is used by the <code>syscall</code> instruction, and so is not free.
You can then make the system call by executing <code>syscall</code>. Before the kernel returns to userspace, it will put the result of the system call (if there is one) in <code>rax</code>.
If a system call takes less than five parameters, the unused parameter registers will be preserved across the system call.</p>
<h1><a class="header" href="#yield" id="yield"><code>yield</code></a></h1>
<p>Used by a task that can't do any work at the moment, allowing the kernel to schedule other tasks.</p>
<h3><a class="header" href="#parameters" id="parameters">Parameters</a></h3>
<p>None.</p>
<h3><a class="header" href="#returns" id="returns">Returns</a></h3>
<p>Always <code>0</code>.</p>
<h3><a class="header" href="#capabilities-needed" id="capabilities-needed">Capabilities needed</a></h3>
<p>None.</p>
<h3><a class="header" href="#early_log" id="early_log"><code>early_log</code></a></h3>
<p>Used by tasks that are started early in the boot process, before reliable userspace logging support is running.
Output is logged to the same place as kernel logging.</p>
<h3><a class="header" href="#parameters-1" id="parameters-1">Parameters</a></h3>
<ul>
<li><code>a</code> - the length of the string to log in bytes. Maximum length is 1024 bytes.</li>
<li><code>b</code> - a usermode pointer to the start of the UTF-8 encoded string.</li>
</ul>
<h3><a class="header" href="#returns-1" id="returns-1">Returns</a></h3>
<ul>
<li><code>0</code> if the system call succeeded</li>
<li><code>1</code> if the string was too long</li>
<li><code>2</code> if the string was not valid UTF-8</li>
<li><code>3</code> if the task making the syscall doesn't have the <code>EarlyLogging</code> capability</li>
</ul>
<h3><a class="header" href="#capabilities-needed-1" id="capabilities-needed-1">Capabilities needed</a></h3>
<p>The <code>EarlyLogging</code> capability is needed to make this system call.</p>
<h1><a class="header" href="#request_system_object" id="request_system_object"><code>request_system_object</code></a></h1>
<p>Used by tasks to request access to a &quot;system&quot; kernel object - usually one created by the kernel to provide
some resource, such as the framebuffer, to userspace. Each object has a hardcoded id used to request it, and
requires the requesting task to have a particular capability - if the task is permitted access to the object,
the kernel returns the kernel object id of the object, and takes any steps needed for the requesting task to
be able to access the object. Normal user tasks probably don't have any need for this system call - it is more
aimed at device drivers and system management tasks.</p>
<p>If this system call is successful, access is granted to the system object from the calling task. This means it
can use the returned id in other system calls.</p>
<h3><a class="header" href="#parameters-2" id="parameters-2">Parameters</a></h3>
<p>The first parameter, <code>a</code>, is always the id (not to be confused with the actual kernel object id, which is not
hardcoded and therefore can change between boots) of the system object. The meaning of the other parameters
depend on the object requested. The allowed values are:</p>
<table><thead><tr><th><code>a</code></th><th>Object being requested</th><th>Type</th><th><code>b</code></th><th><code>c</code></th><th><code>d</code></th><th><code>e</code></th></tr></thead><tbody>
<tr><td><code>0</code></td><td>The backup framebuffer</td><td><code>MemoryObject</code></td><td>-</td><td>-</td><td>-</td><td>-</td></tr>
</tbody></table>
<p>TODO: id for accessing Pci config space where extra params are bus, device, function (+segment or whatever)
numbers.</p>
<h3><a class="header" href="#returns-2" id="returns-2">Returns</a></h3>
<ul>
<li>Bits <code>0..16</code> contain the index of the requested object's ID, if the system call succeeded</li>
<li>Bits <code>16..32</code> contain the generation of the requested object's ID, if the system call succeeded</li>
<li>Bits <code>32..63</code> contain the status of the system call:
<ul>
<li><code>0</code> means the system call succeeded and bits <code>0..32</code> hold a valid kernel object id</li>
<li><code>1</code> means that the requested object is a valid system object, but does not exist</li>
<li><code>2</code> means that the id does not correspond to a valid system object</li>
<li><code>3</code> means that the requested object id is valid, but the task does not have the correct capabilities to
access it</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#capabilities-needed-2" id="capabilities-needed-2">Capabilities needed</a></h3>
<table><thead><tr><th>id</th><th>Capability needed</th></tr></thead><tbody>
<tr><td><code>0</code></td><td><code>AccessBackupFramebuffer</code></td></tr>
</tbody></table>
<h1><a class="header" href="#my_address_space" id="my_address_space"><code>my_address_space</code></a></h1>
<p>Get the ID of the AddressSpace kernel object that the calling task is running in. Tasks do not need a
capability to use this system call, as they automatically have access to their own AddressSpaces, and more
priviledged operations are protected by their own capabilities.</p>
<h3><a class="header" href="#parameters-3" id="parameters-3">Parameters</a></h3>
<p>None.</p>
<h3><a class="header" href="#returns-3" id="returns-3">Returns</a></h3>
<p>The kernel object ID of the AddressSpace of the calling task.</p>
<h3><a class="header" href="#capabilities-needed-3" id="capabilities-needed-3">Capabilities needed</a></h3>
<p>None.</p>
<h1><a class="header" href="#map_memory_object" id="map_memory_object"><code>map_memory_object</code></a></h1>
<p>Map a MemoryObject into an AddressSpace. This requires the calling task to have access to the MemoryObject,
and to the AddressSpace.</p>
<h3><a class="header" href="#parameters-4" id="parameters-4">Parameters</a></h3>
<p><code>a</code> - the kernel object ID of the MemoryObject.
<code>b</code> - the kernel object ID of the AddressSpace to map the MemoryObject into.</p>
<h3><a class="header" href="#returns-4" id="returns-4">Returns</a></h3>
<ul>
<li><code>0</code> if the system call succeeded</li>
<li><code>1</code> if the portion of the AddressSpace that would be mapped is already occupied by another MemoryObject</li>
<li><code>2</code> if the calling task doesn't have access to the MemoryObject</li>
<li><code>3</code> if the calling task doesn't have access to the AddressSpace</li>
<li><code>4</code> if the ID for the MemoryObject does not point to a valid MemoryObject, or if the ID does not point to
any object</li>
<li><code>5</code> if the ID for the AddressSpace does not point to a valid AddressSpace, or if the ID does not point to
any object</li>
</ul>
<h3><a class="header" href="#capabilities-needed-4" id="capabilities-needed-4">Capabilities needed</a></h3>
<p>None (this may change in the future).</p>
<h1><a class="header" href="#capabilities" id="capabilities">Capabilities</a></h1>
<p>Capabilities describe what a task is allowed to do, and are encoded in its image. This allows users to audit the
permissions of the tasks they run at a much higher granularity than user-based permissions, and also allow us to
move parts of the kernel into discrete userspace tasks by creating specialised capabilities to allow access to
sensitive resources (such as the raw framebuffer) to only select tasks.</p>
<h3><a class="header" href="#encoding-capabilities-in-the-elf-image" id="encoding-capabilities-in-the-elf-image">Encoding capabilities in the ELF image</a></h3>
<p>Capabilities are encoded in an entry of a <code>PT_NOTE</code> segment of the ELF image of a task. This entry will have an
owner (sometimes referred to in documentation as the 'name') of <code>PEBBLE</code> and a type of <code>0</code>. The descriptor will be
an encoding of the capabilities as described by the 'Format' section. The descriptor must be padded such that the
next descriptor is 4-byte aligned, and so a value of <code>0x00</code> is reserved to be used as padding.</p>
<p>Initial images (tasks loaded by the bootloader before filesystem drivers are working) are limited to a capabilities
encoding of 32 bytes (given the variable-length encoding, this does not equate to a fixed maximum number of
capabilities).</p>
<h3><a class="header" href="#format" id="format">Format</a></h3>
<p>The capabilities format is variable-length - simple capabilities can be encoded as a single byte, while more
complex / specific ones may need multiple bytes of prefix, and can also encode fixed-length data.</p>
<h3><a class="header" href="#overview-of-capabilities" id="overview-of-capabilities">Overview of capabilities</a></h3>
<p>This is an overview of all the capabilities the kernel supports. Complex capabilities are detailed in their own
sections:</p>
<table><thead><tr><th>First byte</th><th>Next byte(s)</th><th>Data</th><th>Arch specific?</th><th>Description</th><th>Status</th></tr></thead><tbody>
<tr><td><code>0x00</code></td><td>-</td><td>-</td><td>-</td><td>No meaning - used to pad descriptor to required length (see above)</td><td>-</td></tr>
<tr><td><code>0x01</code></td><td></td><td></td><td>No</td><td><code>CreateAddressSpace</code></td><td>Planned</td></tr>
<tr><td><code>0x02</code></td><td></td><td></td><td>No</td><td><code>CreateMemoryObject</code></td><td>Planned</td></tr>
<tr><td><code>0x03</code></td><td></td><td></td><td>No</td><td><code>CreateTask</code></td><td>Planned</td></tr>
<tr><td><code>0x04</code>-<code>0x1f</code></td><td></td><td></td><td></td><td>Reserved for future kernel objects</td><td></td></tr>
<tr><td><code>0x20</code></td><td><code>0x00</code></td><td><code>u16</code> port number</td><td>Yes - x86_64</td><td><code>X86_64AccessIoPort</code></td><td>Planned</td></tr>
<tr><td><code>0x21</code>-<code>0x2f</code></td><td></td><td></td><td></td><td>Reserved for future architectures</td><td></td></tr>
<tr><td><code>0x30</code></td><td></td><td></td><td>No</td><td><code>AccessBackupFramebuffer</code></td><td>Planned</td></tr>
<tr><td><code>0x31</code></td><td></td><td></td><td>No</td><td><code>EarlyLogging</code></td><td>Implemented</td></tr>
</tbody></table>
<h3><a class="header" href="#accessbackupframebuffer" id="accessbackupframebuffer"><code>AccessBackupFramebuffer</code></a></h3>
<p>If a video mode was chosen in the <code>bootcmd</code> and successfully switched to by the bootloader, the framebuffer of that
graphics device will be managed as a <code>MemoryObject</code> kernel object within the kernel. This capability allows a task,
usually the backup framebuffer driver, to request access to that kernel object through the <code>request_system_object</code>
syscall.</p>
<p><strong>NOTE:</strong> while this capability seems quite innocuous, it is anything but. A rouge task that has this capability
could in theory skim sensitive information, such as passwords or credit card details using the framebuffer, if
this driver is in use.</p>
<h3><a class="header" href="#earlylogging" id="earlylogging"><code>EarlyLogging</code></a></h3>
<p>This capability is owned by tasks that are started early in the boot process, before robust userspace logging is
running. It is used to emit logging messages to the kernel log that help debug the early boot process, using the
<code>early_log</code> system call.</p>
<h1><a class="header" href="#userspace-memory-map-x86_64" id="userspace-memory-map-x86_64">Userspace memory map (x86_64)</a></h1>
<p>x86_64 features an enormous 256TB virtual address space, most of which is available to userspace processes under Pebble. For this reason, things are spread throughout the virtual address space to make it
easy to identify what a virtual address points to.</p>
<h3><a class="header" href="#userspace-stacks" id="userspace-stacks">Userspace stacks</a></h3>
<p>Within the virtual address space, the userspace stacks are allocated a 4GB range. Each task has a maximum stack size of 2MB, which puts a limit of 2048 tasks per address space.</p>
<h1><a class="header" href="#message-format" id="message-format">Message Format</a></h1>
<p>Rust's type system can't be used over process boundaries, and so we need another way to encode and decode messages reliably. The soundness of this is incredible important - message passing is Pebble's
largest attack surface, and so the kernel must be able to correctly parse all malformed messaged without violating safety. We also want to make it as easy as possible for developers to build programs that
can send and receive messages.</p>
<p>Every message starts with a header, with the format (the meaning of the <code>ProcessId</code> depends on whether the message is in the Send or Receive buffer):</p>
<pre><code>*----------------------------------* 0x00
| Sender / Recepient (ProcessId)   |
*----------------------------------* 0x02
| Payload length (u16)             |
*----------------------------------* 0x04
</code></pre>
<p>This header is followed by the message's payload, which can represent any type that can be serialized and deserialized by <code>serde</code>. This encoding needs to be compact, but also must be verifiable to be the
correct type of message. Pebble uses a custom encoding format, heavily inspired by <a href="https://github.com/TyOverby/bincode">BinCode</a> and <a href="https://github.com/msgpack/msgpack/blob/master/spec.md">MessagePack</a>.
By effectively having a tiny type system that closely resembles the Serde data model, we can sanity-check that the types we're deserializing into will make at least some sense.</p>
<h3><a class="header" href="#encoding-types" id="encoding-types">Encoding types</a></h3>
<p>To handle any type that can be serialized and deserialized using <code>serde</code>, we need to be able to handle the 29 types of the Serde Data Model. While lots of these types are specifically tagged, some are
encoded transparently for simplicity and compactness (specifically <code>Newtype Struct</code> and <code>Newtype Variant</code>). All multi-byte structures are little-endian. <code>Struct</code>s and <code>Tuple</code>s are simply encoded by encoding
each of their fields in order.</p>
<p>TODO XXX: I don't think this is fully good yet. We should think about how long structures are actually going to be (e.g. how long should a string actually be able to be?), and decide if the extra compactness is worth it for e.g. missing out an extra 1 byte of length info...</p>
<table><thead><tr><th>First byte</th><th>Number of following bytes</th><th>Format</th><th>Description</th></tr></thead><tbody>
<tr><td>0x00</td><td>0</td><td></td><td><code>Unit</code>, <code>Unit Struct</code>, <code>Unit Variant</code></td></tr>
<tr><td>0x01</td><td>0</td><td></td><td><code>bool</code> - False</td></tr>
<tr><td>0x02</td><td>0</td><td></td><td><code>bool</code> - True</td></tr>
<tr><td>0x03</td><td>0</td><td></td><td><code>None</code></td></tr>
<tr><td>0x04</td><td><code>n</code></td><td>XX(<code>n</code>)</td><td><code>Some(T)</code> (this marks the <code>Some</code>. The <code>T</code> is then encoded after this byte)</td></tr>
<tr><td>0x05</td><td>1</td><td>CC</td><td><code>char</code> - UTF-8 code point that requires 1 byte to encode</td></tr>
<tr><td>0x06</td><td>2</td><td>CC-CC</td><td><code>char</code> - UTF-8 code point that requires 2 byte to encode</td></tr>
<tr><td>0x07</td><td>3</td><td>CC-CC-CC</td><td><code>char</code> - UTF-8 code point that requires 3 byte to encode</td></tr>
<tr><td>0x08</td><td>4</td><td>CC-CC-CC-CC</td><td><code>char</code> - UTF-8 code point that requires 4 byte to encode</td></tr>
<tr><td>0x10</td><td>1</td><td>XX</td><td><code>u8</code></td></tr>
<tr><td>0x11</td><td>2</td><td>XX-XX</td><td><code>u16</code></td></tr>
<tr><td>0x12</td><td>4</td><td>XX-XX-XX-XX</td><td><code>u32</code></td></tr>
<tr><td>0x13</td><td>8</td><td>XX-XX-XX-XX-XX-XX-XX-XX</td><td><code>u64</code></td></tr>
<tr><td>0x14</td><td>16</td><td>XX(16)</td><td><code>u128</code></td></tr>
<tr><td>0x20</td><td>1</td><td>ZZ</td><td><code>i8</code></td></tr>
<tr><td>0x21</td><td>2</td><td>ZZ-ZZ</td><td><code>i16</code></td></tr>
<tr><td>0x22</td><td>4</td><td>ZZ-ZZ-ZZ-ZZ</td><td><code>i32</code></td></tr>
<tr><td>0x23</td><td>8</td><td>ZZ-ZZ-ZZ-ZZ-ZZ-ZZ-ZZ-ZZ</td><td><code>i64</code></td></tr>
<tr><td>0x24</td><td>16</td><td>ZZ(16)</td><td><code>i128</code></td></tr>
<tr><td>0x30</td><td>4</td><td>FF-FF-FF-FF</td><td><code>f32</code></td></tr>
<tr><td>0x31</td><td>8</td><td>FF-FF-FF-FF-FF-FF-FF-FF</td><td><code>f64</code></td></tr>
<tr><td>0x40-0x4F</td><td>(1-16){<code>n</code>} + <code>n</code> of data</td><td>NN(<code>first</code> - 0x3F)-CC(<code>n</code>)</td><td><code>String</code></td></tr>
<tr><td>0x50-0x5F</td><td>(1-16){<code>n</code>} + <code>n</code> of data</td><td>NN(<code>first</code> - 0x4F)-XX(<code>n</code>)</td><td><code>Byte Array</code></td></tr>
<tr><td>0x60</td><td>4{<code>n</code>} + <code>n</code> of data</td><td>NN-NN-NN-NN-XX(<code>n</code>)</td><td><code>Seq</code></td></tr>
</tbody></table>
<h4><a class="header" href="#strings" id="strings">Strings</a></h4>
<p>Strings are encoded as UTF-8 byte arrays without null terminators. The first byte defines how many bytes are used to encode the length of the string, where <code>0x40</code> means 1 byte is used and <code>0x4F</code> means 16
bytes are used (this is <code>x</code>). The following <code>x</code> bytes are used to encode the number of bytes used to encode the string (<code>n</code>). Following this are <code>n</code> bytes of UTF-8 string data.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
