<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pebble OS</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="kernel/index.html"><strong aria-hidden="true">2.</strong> The Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kernel/bootcmd.html"><strong aria-hidden="true">2.1.</strong> Bootcmd</a></li><li class="chapter-item expanded "><a href="kernel/booting_x86_64.html"><strong aria-hidden="true">2.2.</strong> Booting (x86_64)</a></li><li class="chapter-item expanded "><a href="kernel/kernel_objects.html"><strong aria-hidden="true">2.3.</strong> Kernel Objects</a></li><li class="chapter-item expanded "><a href="kernel/syscalls.html"><strong aria-hidden="true">2.4.</strong> System calls</a></li></ol></li><li class="chapter-item expanded "><a href="syscalls/index.html"><strong aria-hidden="true">3.</strong> Syscalls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syscalls/yield.html"><strong aria-hidden="true">3.1.</strong> yield</a></li><li class="chapter-item expanded "><a href="syscalls/early_log.html"><strong aria-hidden="true">3.2.</strong> early_log</a></li><li class="chapter-item expanded "><a href="syscalls/request_system_object.html"><strong aria-hidden="true">3.3.</strong> request_system_object</a></li><li class="chapter-item expanded "><a href="syscalls/my_address_space.html"><strong aria-hidden="true">3.4.</strong> my_address_space</a></li><li class="chapter-item expanded "><a href="syscalls/map_memory_object.html"><strong aria-hidden="true">3.5.</strong> map_memory_object</a></li></ol></li><li class="chapter-item expanded "><a href="userspace/index.html"><strong aria-hidden="true">4.</strong> Userspace</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="userspace/capabilities.html"><strong aria-hidden="true">4.1.</strong> Capabilities</a></li><li class="chapter-item expanded "><a href="userspace/memory_map_x86_64.html"><strong aria-hidden="true">4.2.</strong> Memory map (x86_64)</a></li></ol></li><li class="chapter-item expanded "><a href="message_passing/index.html"><strong aria-hidden="true">5.</strong> Message Passing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="message_passing/fmt.html"><strong aria-hidden="true">5.1.</strong> Message Format</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Pebble OS</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to the Pebble Book, which serves as the main source of documentation for <a href="https://github.com/IsaacWoods/pebble">Pebble OS</a>.
The Book aims to be both a 10,000-meter overview of Pebble for the interested observer, and a definitive reference for the inner workings of the kernel and userspace. </p>
<p>Please note that this book (like the rest of the OS!) is still very early in development and not at all complete.
If anything is unclear, please <a href="https://github.com/IsaacWoods/pebble/issues">file an issue</a>!</p>
<p><strong>Some things documented in this book don't exist in Pebble yet. I use the book as in-progress documentation as I design stuff so I don't have to keep it all in my head.</strong></p>
<h3><a class="header" href="#what-is-pebble" id="what-is-pebble">What is Pebble?</a></h3>
<p>At heart, Pebble is a microkernel written in the <a href="https://rust-lang.org">Rust programming language</a>.
Pebble becomes an &quot;OS&quot; when it's combined with other packages such as display and window servers, filesystems and user applications.</p>
<p>Pebble is designed to be a modern microkernel, supporting a minimal system call interface and first-class support for message-passing-based IPC between userspace processes. Versatile message-passing allows
Pebble to move much more out of the kernel than traditionally possible. For example, the kernel has no concept of a filesystem or of files - instead, the VFS and all filesystems are implemented entirely in
userspace, and files are read and written to by passing messages.</p>
<h3><a class="header" href="#why-rust" id="why-rust">Why Rust?</a></h3>
<p>While Pebble's design is in theory language-agnostic, the implementation is very tied to Rust. Rust is a systems programming language with a rich type system and a novel ownership model that guarantees
memory and thread safety <strong>in safe code</strong>. This qualification is important, as Pebble uses a lot of <code>unsafe</code> code out of necessity - it's important to understand that the use of Rust does not in any way
mean that Pebble is automatically bug-free.</p>
<p>However, Rust makes you think a lot more about how to make your programs safe, which is exactly the sort of code we want to be writing for a kernel. This focus on safety, as well as good ergonomics features
and performance, makes Rust perfect for OS-level code.</p>
<h3><a class="header" href="#arch-modules" id="arch-modules">Arch modules</a></h3>
<p>Each architecture has its own module that deals with platform-specific initialization and platform management.
When building, a single architecture module is selected using an architecture feature. Through conditional
compilation, only the selected architecture module is compiled and included in the final kernel executable.</p>
<p>Every architecture module is expected to provide certain items for the benefit of the platform-independent
parts of the kernel:</p>
<ul>
<li><code>Arch</code> - A type that implements the <code>Architecture</code> trait.</li>
<li><code>common_per_cpu_data</code> - A function to access the common per-cpu data.</li>
<li><code>common_per_cpu_data_mut</code> - A function to mutably access the common per-cpu data.</li>
<li><code>context_switch</code> - A function to perform a context switch between the currently running task and another task.</li>
</ul>
<h1><a class="header" href="#bootcmd" id="bootcmd">Bootcmd</a></h1>
<p>The <code>bootcmd</code> is a file loaded by the bootloader that contains instructions for booting into an instance of Pebble.
It is located at the root of the boot medium (e.g. in the FAT partition if using the UEFI bootloader for x86_64),
and consists of a series of line-separated commands that load / configure parts of the OS.</p>
<h3><a class="header" href="#commands" id="commands">Commands</a></h3>
<ul>
<li><code>kernel {path}</code> - load the kernel image at the specified path into memory. This command must be present for the
bootloader to successfully boot, and must only appear once in the <code>bootcmd</code>.</li>
<li><code>image {path} {name}</code> - load an initial task image into memory and pass information about it to the kernel. This
command is used to load initial tasks for the kernel to run before it has functioning filesystem drivers. It
can also be used to load all tasks needed in minimal systems. It can be present zero or more times in the
<code>bootcmd</code>. The same image should not be loaded more than once, however.</li>
<li><code>video_mode {desired width} {desired height}</code> - attempts to set up a video mode for initial graphics support (if
a better driver isn't available / loaded). The exact behaviour of this command will depend on the platform
being booted upon, but it will in general try to switch to an appropriate mode, pass information about that
mode to the kernel, which will pass it on to the task with the <code>CAP_MAP_FRAMEBUFFER</code> capability (refer to
the 'Userspace/Capabilities' section for more information)</li>
</ul>
<h1><a class="header" href="#booting-pebble-on-x86_64" id="booting-pebble-on-x86_64">Booting Pebble on x86_64</a></h1>
<p>On x86_64, Pebble is booted by a UEFI application that can be found <a href="https://github.com/pebble-os/pebble/tree/master/bootloader">here</a>. We don't support booting from BIOS, mainly because the vast majority
of current platforms now support UEFI, and I didn't want the maintenance burden of two bootloaders for one platform. Pebble's kernel and bootloaders are more coupled than on other platforms, and the
bootloader does a lot more of the platform-specific initialization than generic bootloaders like GRUB2. On x86_64, doing this initialization in the bootloader allows us to use the Boot Services provided by
the UEFI, which simplifies early bring-up considerably.</p>
<p>The bootloader is responsible for setting up a sensible environment for the kernel to run in, as well as doing initialization that makes use of the Boot Services that are not available after we've loaded the
kernel. This is much easier than it would be if we supported the BIOS, as UEFI already defines a fairly sane environment. The bootloader:</p>
<ul>
<li>Finds and switches to a suitable graphics mode</li>
<li>Loads the kernel's image from the boot partition, loads its sections, and creates a set of page tables for it</li>
<li>Loads the payload's image from the boot partition, loads its sections, and creates a set of page tables for it</li>
<li>Allocates backing memory for the kernel heap</li>
<li>Sets up paging and creates page tables with the correct kernel-space mappings</li>
<li>Jumps into the kernel</li>
</ul>
<h3><a class="header" href="#loading-the-kernel" id="loading-the-kernel">Loading the kernel</a></h3>
<p>The kernel is an ELF file on the boot partition. Only its allocatable sections are mapped into memory. The kernel is expected to have a couple of special symbols defined, which are used by the bootloader:</p>
<ul>
<li><code>_guard_page</code> - the start address of the guard page. This is purposefully unmapped by the bootloader, so that stack overflows cause page-faults</li>
<li><code>_stack_bottom</code> and <code>_stack_top</code> - define the bottom and top of the stack, respectively. These are defined as part of the <code>.bss</code> section, so the bootloader doesn't have to manually allocate a stack. The 
address is provided so the bootloader knows what to set <code>rsp</code> to before it jumps into the kernel</li>
</ul>
<h3><a class="header" href="#loading-the-kernel-payload" id="loading-the-kernel-payload">Loading the kernel payload</a></h3>
<p>While we have the luxury of the UEFI's filesystem drivers being available, we also load another ELF image called the 'kernel payload'. This is the first process launched by the kernel, and is usually
responsible for starting a set of other processes from an embedded initial filesystem. Alternatively, a simple application can be provided as a payload, for example in embedded contexts.</p>
<p>While it seems like a strange choice, we load this in the bootloader so that the kernel doesn't have to have any logic to do so. Pebble The Microkernel has no concept of files, of ramdisks, or of what an ELF
file looks like inside - it simply accepts sets of page tables and created processes out of them. This makes the kernel much simpler and less bug-prone, at the expense of making the bootloader slightly more
complex.</p>
<h1><a class="header" href="#kernel-objects" id="kernel-objects">Kernel Objects</a></h1>
<p>Kernel Objects are how Pebble represents resources that can be interacted with from userspace. They are all
allocated an ID that can be passed into userspace</p>
<h3><a class="header" href="#using-generational-ids-for-kernel-objects" id="using-generational-ids-for-kernel-objects">Using generational IDs for kernel objects</a></h3>
<p>Pebble, inspired by <a href="https://www.youtube.com/watch?v=aKLntZcp27M">Catherine West's Rustconf 2018 keynote</a>, uses
generational IDs to refer to kernel objects. This means that IDs are comprised of two numbers:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct KernelObjectId {
    index: u16,
    generation: u16,
}
<span class="boring">}
</span></code></pre></pre>
<p>The meaning of these numbers is internal to how the kernel manages the allocation of IDs, and can be ignored by the
rest of the system.</p>
<p>The key motivation behind this is called the <a href="https://en.wikipedia.org/wiki/ABA_problem">the ABA problem</a>. Because
kernel objects can be created and destroyed at any point, an ID that you've cached can stop pointing to the object
you think it points to - lots of systems solve this problem by never reusing IDs (once an object is destroyed, its
ID is not reallocated). However, this often requires complex data structures to make efficient use of memory, and
so Pebble uses generational IDs instead (where the index remains a simple index into the backing memory).</p>
<h1><a class="header" href="#system-calls" id="system-calls">System calls</a></h1>
<p>Userspace code can interact with the kernel through system calls. Pebble's system call interface is based around
'kernel objects', and so many of the system calls are to create, destroy, or modify the state of various types of
kernel object. Because of Pebble's microkernel design, many traditional system calls (e.g. <code>open</code>) are not present,
their functionality instead being provided by userspace.</p>
<p>Each system call has a unique number that is used to identify it. A system call can then take up to five
parameters, each a maximum in size of the system's register width. It can return a single value, also the size of
a register.</p>
<h3><a class="header" href="#overview-of-system-calls" id="overview-of-system-calls">Overview of system calls</a></h3>
<table><thead><tr><th>Number</th><th>System call</th><th>Description</th></tr></thead><tbody>
<tr><td><code>0</code></td><td><code>yield</code></td><td>Yield to the kernel.</td></tr>
<tr><td><code>1</code></td><td><code>early_log</code></td><td>Log a message. Designed to be used from early processes.</td></tr>
<tr><td><code>2</code></td><td><code>request_system_object</code></td><td>Request a handle for a system kernel object.</td></tr>
<tr><td><code>3</code></td><td><code>my_address_space</code></td><td>Get a handle to the calling task's AddressSpace.</td></tr>
<tr><td><code>4</code></td><td><code>create_memory_object</code></td><td>Create a MemoryObject kernel object.</td></tr>
<tr><td><code>5</code></td><td><code>map_memory_object</code></td><td>Map a MemoryObject into an AddressSpace.</td></tr>
</tbody></table>
<h3><a class="header" href="#making-a-system-call-on-x86_64" id="making-a-system-call-on-x86_64">Making a system call on x86_64</a></h3>
<p>To make a system call on x86_64, populate these registers:</p>
<table><thead><tr><th><code>rdi</code></th><th><code>rsi</code></th><th><code>rdx</code></th><th><code>r10</code></th><th><code>r8</code></th><th><code>r9</code></th></tr></thead><tbody>
<tr><td>System call number</td><td><code>a</code></td><td><code>b</code></td><td><code>c</code></td><td><code>d</code></td><td><code>e</code></td></tr>
</tbody></table>
<p>The only way in which these registers deviate from the x86_64 Sys-V ABI is that <code>c</code> is passed in <code>r10</code> instead
of <code>rcx</code>. This is because <code>rcx</code> is used by the <code>syscall</code> instruction, and so is not free.
You can then make the system call by executing <code>syscall</code>. Before the kernel returns to userspace, it will put the
result of the system call (if there is one) in <code>rax</code>. If a system call takes less than five parameters, the unused
parameter registers will be preserved across the system call.</p>
<h3><a class="header" href="#return-values" id="return-values">Return values</a></h3>
<p>Often, a system call needs to return a status, plus a number of handles. We use a common pattern to make this easier:</p>
<ul>
<li>Bits <code>0..16</code> contain the status:
<ul>
<li><code>0</code> means that the system call succeeded, and the rest of the return value is valid</li>
<li><code>&gt;0</code> means that the system call errored. The meaning of the value is system-call specific.</li>
</ul>
</li>
<li>Bits <code>16..32</code> contain the 1st handle returned to userspace, if applicable</li>
<li>Bits <code>32..48</code> contain the 2nd handle returned to userspace, if applicable</li>
<li>Bits <code>48..64</code> contain the 3rd handle returned to userspace, if applicable</li>
</ul>
<h1><a class="header" href="#yield" id="yield"><code>yield</code></a></h1>
<p>Used by a task that can't do any work at the moment, allowing the kernel to schedule other tasks.</p>
<h3><a class="header" href="#parameters" id="parameters">Parameters</a></h3>
<p>None.</p>
<h3><a class="header" href="#returns" id="returns">Returns</a></h3>
<p>Always <code>0</code>.</p>
<h3><a class="header" href="#capabilities-needed" id="capabilities-needed">Capabilities needed</a></h3>
<p>None.</p>
<h3><a class="header" href="#early_log" id="early_log"><code>early_log</code></a></h3>
<p>Used by tasks that are started early in the boot process, before reliable userspace logging support is running.
Output is logged to the same place as kernel logging.</p>
<h3><a class="header" href="#parameters-1" id="parameters-1">Parameters</a></h3>
<ul>
<li><code>a</code> - the length of the string to log in bytes. Maximum length is 1024 bytes.</li>
<li><code>b</code> - a usermode pointer to the start of the UTF-8 encoded string.</li>
</ul>
<h3><a class="header" href="#returns-1" id="returns-1">Returns</a></h3>
<ul>
<li><code>0</code> if the system call succeeded</li>
<li><code>1</code> if the string was too long</li>
<li><code>2</code> if the string was not valid UTF-8</li>
<li><code>3</code> if the task making the syscall doesn't have the <code>EarlyLogging</code> capability</li>
</ul>
<h3><a class="header" href="#capabilities-needed-1" id="capabilities-needed-1">Capabilities needed</a></h3>
<p>The <code>EarlyLogging</code> capability is needed to make this system call.</p>
<h1><a class="header" href="#request_system_object" id="request_system_object"><code>request_system_object</code></a></h1>
<p>Used by tasks to request access to a &quot;system&quot; kernel object - usually one created by the kernel to provide
some resource, such as the framebuffer, to userspace. Each object has a hardcoded id used to request it, and
requires the requesting task to have a particular capability - if the task is permitted access to the object,
the kernel returns the kernel object id of the object, and takes any steps needed for the requesting task to
be able to access the object. Normal user tasks probably don't have any need for this system call - it is more
aimed at device drivers and system management tasks.</p>
<p>If this system call is successful, access is granted to the system object from the calling task. This means it
can use the returned id in other system calls.</p>
<h3><a class="header" href="#parameters-2" id="parameters-2">Parameters</a></h3>
<p>The first parameter, <code>a</code>, is always the id (not to be confused with the actual kernel object id, which is not
hardcoded and therefore can change between boots) of the system object. The meaning of the other parameters
depend on the object requested. The allowed values are:</p>
<table><thead><tr><th><code>a</code></th><th>Object being requested</th><th>Type</th><th><code>b</code></th><th><code>c</code></th><th><code>d</code></th><th><code>e</code></th></tr></thead><tbody>
<tr><td><code>0</code></td><td>The backup framebuffer</td><td><code>MemoryObject</code></td><td>ptr to info</td><td>-</td><td>-</td><td>-</td></tr>
</tbody></table>
<p>TODO: id for accessing Pci config space where extra params are bus, device, function (+segment or whatever)
numbers.</p>
<h3><a class="header" href="#returns-2" id="returns-2">Returns</a></h3>
<p>This system call uses the standard way to fallibly return a <code>KernelObjectId</code> (detailed in the
<a href="syscalls/../kernel/syscalls.html">page on syscalls</a>). The status codes used are:</p>
<ul>
<li><code>0</code> means that the system call was successful</li>
<li><code>1</code> means that the requested ID is valid, but that the system object hasn't been created</li>
<li><code>2</code> means that the ID does not correspond to a valid system object</li>
<li><code>3</code> means that the requested object ID is valid, but that the task does not have the correct capability
to access it. This is returned even if the system object doesn't exist.</li>
</ul>
<h3><a class="header" href="#capabilities-needed-2" id="capabilities-needed-2">Capabilities needed</a></h3>
<table><thead><tr><th>id</th><th>Capability needed</th></tr></thead><tbody>
<tr><td><code>0</code></td><td><code>AccessBackupFramebuffer</code></td></tr>
</tbody></table>
<h3><a class="header" href="#system-object-backup-framebuffer" id="system-object-backup-framebuffer">System object: backup framebuffer</a></h3>
<p>An ID of <code>0</code> corresponds to the backup framebuffer system object - a framebuffer created by the bootloader or
kernel that can be used if there is not a more specialized graphics driver available (e.g. on x86_64, this uses the
UEFI Graphics Output Protocol to create a basic linear framebuffer). The object is a <code>MemoryObject</code> that is meant
to be mapped into the userspace driver and directly written to as video memory.</p>
<p>A userspace address should be passed as <code>b</code>, which is used to pass information about the framebuffer back to
userspace from the kernel. The memory must be user-accessible and writable. The format of the written structure is:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct FramebufferInfo {
    /// The address of the start of the framebuffer
    address: usize,

    width: u16,
    height: u16,
    stride: u16,
    /// 0 = RGB32
    /// 1 = BGR32
    pixel_format: u8,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#my_address_space" id="my_address_space"><code>my_address_space</code></a></h1>
<p>Get the ID of the AddressSpace kernel object that the calling task is running in. Tasks do not need a
capability to use this system call, as they automatically have access to their own AddressSpaces, and more
priviledged operations are protected by their own capabilities.</p>
<h3><a class="header" href="#parameters-3" id="parameters-3">Parameters</a></h3>
<p>None.</p>
<h3><a class="header" href="#returns-3" id="returns-3">Returns</a></h3>
<p>The kernel object ID of the AddressSpace of the calling task.</p>
<h3><a class="header" href="#capabilities-needed-3" id="capabilities-needed-3">Capabilities needed</a></h3>
<p>None.</p>
<h1><a class="header" href="#map_memory_object" id="map_memory_object"><code>map_memory_object</code></a></h1>
<p>Map a MemoryObject into an AddressSpace. This requires the calling task to have access to the MemoryObject,
and to the AddressSpace.</p>
<h3><a class="header" href="#parameters-4" id="parameters-4">Parameters</a></h3>
<p><code>a</code> - the kernel object ID of the MemoryObject.
<code>b</code> - the kernel object ID of the AddressSpace to map the MemoryObject into.</p>
<h3><a class="header" href="#returns-4" id="returns-4">Returns</a></h3>
<ul>
<li><code>0</code> if the system call succeeded</li>
<li><code>1</code> if the portion of the AddressSpace that would be mapped is already occupied by another MemoryObject</li>
<li><code>2</code> if the calling task doesn't have access to the MemoryObject</li>
<li><code>3</code> if the calling task doesn't have access to the AddressSpace</li>
<li><code>4</code> if the ID for the MemoryObject does not point to a valid MemoryObject, or if the ID does not point to
any object</li>
<li><code>5</code> if the ID for the AddressSpace does not point to a valid AddressSpace, or if the ID does not point to
any object</li>
</ul>
<h3><a class="header" href="#capabilities-needed-4" id="capabilities-needed-4">Capabilities needed</a></h3>
<p>None (this may change in the future).</p>
<h1><a class="header" href="#capabilities" id="capabilities">Capabilities</a></h1>
<p>Capabilities describe what a task is allowed to do, and are encoded in its image. This allows users to audit the
permissions of the tasks they run at a much higher granularity than user-based permissions, and also allow us to
move parts of the kernel into discrete userspace tasks by creating specialised capabilities to allow access to
sensitive resources (such as the raw framebuffer) to only select tasks.</p>
<h3><a class="header" href="#encoding-capabilities-in-the-elf-image" id="encoding-capabilities-in-the-elf-image">Encoding capabilities in the ELF image</a></h3>
<p>Capabilities are encoded in an entry of a <code>PT_NOTE</code> segment of the ELF image of a task. This entry will have an
owner (sometimes referred to in documentation as the 'name') of <code>PEBBLE</code> and a type of <code>0</code>. The descriptor will be
an encoding of the capabilities as described by the 'Format' section. The descriptor must be padded such that the
next descriptor is 4-byte aligned, and so a value of <code>0x00</code> is reserved to be used as padding.</p>
<p>Initial images (tasks loaded by the bootloader before filesystem drivers are working) are limited to a capabilities
encoding of 32 bytes (given the variable-length encoding, this does not equate to a fixed maximum number of
capabilities).</p>
<h3><a class="header" href="#format" id="format">Format</a></h3>
<p>The capabilities format is variable-length - simple capabilities can be encoded as a single byte, while more
complex / specific ones may need multiple bytes of prefix, and can also encode fixed-length data.</p>
<h3><a class="header" href="#overview-of-capabilities" id="overview-of-capabilities">Overview of capabilities</a></h3>
<p>This is an overview of all the capabilities the kernel supports. Complex capabilities are detailed in their own
sections:</p>
<table><thead><tr><th>First byte</th><th>Next byte(s)</th><th>Data</th><th>Arch specific?</th><th>Description</th><th>Status</th></tr></thead><tbody>
<tr><td><code>0x00</code></td><td>-</td><td>-</td><td>-</td><td>No meaning - used to pad descriptor to required length (see above)</td><td>-</td></tr>
<tr><td><code>0x01</code></td><td></td><td></td><td>No</td><td><code>CreateAddressSpace</code></td><td>Planned</td></tr>
<tr><td><code>0x02</code></td><td></td><td></td><td>No</td><td><code>CreateMemoryObject</code></td><td>Planned</td></tr>
<tr><td><code>0x03</code></td><td></td><td></td><td>No</td><td><code>CreateTask</code></td><td>Planned</td></tr>
<tr><td><code>0x04</code>-<code>0x1f</code></td><td></td><td></td><td></td><td>Reserved for future kernel objects</td><td></td></tr>
<tr><td><code>0x20</code></td><td><code>0x00</code></td><td><code>u16</code> port number</td><td>Yes - x86_64</td><td><code>X86_64AccessIoPort</code></td><td>Planned</td></tr>
<tr><td><code>0x21</code>-<code>0x2f</code></td><td></td><td></td><td></td><td>Reserved for future architectures</td><td></td></tr>
<tr><td><code>0x30</code></td><td></td><td></td><td>No</td><td><code>AccessBackupFramebuffer</code></td><td>Planned</td></tr>
<tr><td><code>0x31</code></td><td></td><td></td><td>No</td><td><code>EarlyLogging</code></td><td>Implemented</td></tr>
</tbody></table>
<h3><a class="header" href="#accessbackupframebuffer" id="accessbackupframebuffer"><code>AccessBackupFramebuffer</code></a></h3>
<p>If a video mode was chosen in the <code>bootcmd</code> and successfully switched to by the bootloader, the framebuffer of that
graphics device will be managed as a <code>MemoryObject</code> kernel object within the kernel. This capability allows a task,
usually the backup framebuffer driver, to request access to that kernel object through the <code>request_system_object</code>
syscall.</p>
<p><strong>NOTE:</strong> while this capability seems quite innocuous, it is anything but. A rouge task that has this capability
could in theory skim sensitive information, such as passwords or credit card details using the framebuffer, if
this driver is in use.</p>
<h3><a class="header" href="#earlylogging" id="earlylogging"><code>EarlyLogging</code></a></h3>
<p>This capability is owned by tasks that are started early in the boot process, before robust userspace logging is
running. It is used to emit logging messages to the kernel log that help debug the early boot process, using the
<code>early_log</code> system call.</p>
<h1><a class="header" href="#userspace-memory-map-x86_64" id="userspace-memory-map-x86_64">Userspace memory map (x86_64)</a></h1>
<p>x86_64 features an enormous 256TB virtual address space, most of which is available to userspace processes under Pebble. For this reason, things are spread throughout the virtual address space to make it
easy to identify what a virtual address points to.</p>
<h3><a class="header" href="#userspace-stacks" id="userspace-stacks">Userspace stacks</a></h3>
<p>Within the virtual address space, the userspace stacks are allocated a 4GB range. Each task has a maximum stack size of 2MB, which puts a limit of 2048 tasks per address space.</p>
<h1><a class="header" href="#message-format" id="message-format">Message Format</a></h1>
<p>Rust's type system can't be used over process boundaries, and so we need another way to encode and decode messages reliably. The soundness of this is incredible important - message passing is Pebble's
largest attack surface, and so the kernel must be able to correctly parse all malformed messaged without violating safety. We also want to make it as easy as possible for developers to build programs that
can send and receive messages.</p>
<p>Every message starts with a header, with the format (the meaning of the <code>ProcessId</code> depends on whether the message is in the Send or Receive buffer):</p>
<pre><code>*----------------------------------* 0x00
| Sender / Recepient (ProcessId)   |
*----------------------------------* 0x02
| Payload length (u16)             |
*----------------------------------* 0x04
</code></pre>
<p>This header is followed by the message's payload, which can represent any type that can be serialized and deserialized by <code>serde</code>. This encoding needs to be compact, but also must be verifiable to be the
correct type of message. Pebble uses a custom encoding format, heavily inspired by <a href="https://github.com/TyOverby/bincode">BinCode</a> and <a href="https://github.com/msgpack/msgpack/blob/master/spec.md">MessagePack</a>.
By effectively having a tiny type system that closely resembles the Serde data model, we can sanity-check that the types we're deserializing into will make at least some sense.</p>
<h3><a class="header" href="#encoding-types" id="encoding-types">Encoding types</a></h3>
<p>To handle any type that can be serialized and deserialized using <code>serde</code>, we need to be able to handle the 29 types of the Serde Data Model. While lots of these types are specifically tagged, some are
encoded transparently for simplicity and compactness (specifically <code>Newtype Struct</code> and <code>Newtype Variant</code>). All multi-byte structures are little-endian. <code>Struct</code>s and <code>Tuple</code>s are simply encoded by encoding
each of their fields in order.</p>
<p>TODO XXX: I don't think this is fully good yet. We should think about how long structures are actually going to be (e.g. how long should a string actually be able to be?), and decide if the extra compactness is worth it for e.g. missing out an extra 1 byte of length info...</p>
<table><thead><tr><th>First byte</th><th>Number of following bytes</th><th>Format</th><th>Description</th></tr></thead><tbody>
<tr><td>0x00</td><td>0</td><td></td><td><code>Unit</code>, <code>Unit Struct</code>, <code>Unit Variant</code></td></tr>
<tr><td>0x01</td><td>0</td><td></td><td><code>bool</code> - False</td></tr>
<tr><td>0x02</td><td>0</td><td></td><td><code>bool</code> - True</td></tr>
<tr><td>0x03</td><td>0</td><td></td><td><code>None</code></td></tr>
<tr><td>0x04</td><td><code>n</code></td><td>XX(<code>n</code>)</td><td><code>Some(T)</code> (this marks the <code>Some</code>. The <code>T</code> is then encoded after this byte)</td></tr>
<tr><td>0x05</td><td>1</td><td>CC</td><td><code>char</code> - UTF-8 code point that requires 1 byte to encode</td></tr>
<tr><td>0x06</td><td>2</td><td>CC-CC</td><td><code>char</code> - UTF-8 code point that requires 2 byte to encode</td></tr>
<tr><td>0x07</td><td>3</td><td>CC-CC-CC</td><td><code>char</code> - UTF-8 code point that requires 3 byte to encode</td></tr>
<tr><td>0x08</td><td>4</td><td>CC-CC-CC-CC</td><td><code>char</code> - UTF-8 code point that requires 4 byte to encode</td></tr>
<tr><td>0x10</td><td>1</td><td>XX</td><td><code>u8</code></td></tr>
<tr><td>0x11</td><td>2</td><td>XX-XX</td><td><code>u16</code></td></tr>
<tr><td>0x12</td><td>4</td><td>XX-XX-XX-XX</td><td><code>u32</code></td></tr>
<tr><td>0x13</td><td>8</td><td>XX-XX-XX-XX-XX-XX-XX-XX</td><td><code>u64</code></td></tr>
<tr><td>0x14</td><td>16</td><td>XX(16)</td><td><code>u128</code></td></tr>
<tr><td>0x20</td><td>1</td><td>ZZ</td><td><code>i8</code></td></tr>
<tr><td>0x21</td><td>2</td><td>ZZ-ZZ</td><td><code>i16</code></td></tr>
<tr><td>0x22</td><td>4</td><td>ZZ-ZZ-ZZ-ZZ</td><td><code>i32</code></td></tr>
<tr><td>0x23</td><td>8</td><td>ZZ-ZZ-ZZ-ZZ-ZZ-ZZ-ZZ-ZZ</td><td><code>i64</code></td></tr>
<tr><td>0x24</td><td>16</td><td>ZZ(16)</td><td><code>i128</code></td></tr>
<tr><td>0x30</td><td>4</td><td>FF-FF-FF-FF</td><td><code>f32</code></td></tr>
<tr><td>0x31</td><td>8</td><td>FF-FF-FF-FF-FF-FF-FF-FF</td><td><code>f64</code></td></tr>
<tr><td>0x40-0x4F</td><td>(1-16){<code>n</code>} + <code>n</code> of data</td><td>NN(<code>first</code> - 0x3F)-CC(<code>n</code>)</td><td><code>String</code></td></tr>
<tr><td>0x50-0x5F</td><td>(1-16){<code>n</code>} + <code>n</code> of data</td><td>NN(<code>first</code> - 0x4F)-XX(<code>n</code>)</td><td><code>Byte Array</code></td></tr>
<tr><td>0x60</td><td>4{<code>n</code>} + <code>n</code> of data</td><td>NN-NN-NN-NN-XX(<code>n</code>)</td><td><code>Seq</code></td></tr>
</tbody></table>
<h4><a class="header" href="#strings" id="strings">Strings</a></h4>
<p>Strings are encoded as UTF-8 byte arrays without null terminators. The first byte defines how many bytes are used to encode the length of the string, where <code>0x40</code> means 1 byte is used and <code>0x4F</code> means 16
bytes are used (this is <code>x</code>). The following <code>x</code> bytes are used to encode the number of bytes used to encode the string (<code>n</code>). Following this are <code>n</code> bytes of UTF-8 string data.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
